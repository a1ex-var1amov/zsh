# --- Homebrew completions BEFORE compinit ---
if [[ -d /opt/homebrew/share/zsh/site-functions ]]; then
  fpath=(/opt/homebrew/share/zsh/site-functions $fpath)
elif [[ -d /usr/local/share/zsh/site-functions ]]; then
  fpath=(/usr/local/share/zsh/site-functions $fpath)
fi

# IMPORTANT: Do NOT override TERM when using Ghostty
# Ghostty sets its own TERM (ghostty or xterm-ghostty) with proper terminfo
# Overriding breaks escape sequences (like ESC in vim)
if [[ -z "$GHOSTTY_RESOURCES_DIR" ]]; then
  # Only set TERM for non-Ghostty terminals
  export TERM="xterm-256color"
fi

# --- Ghostty shell integration (load early) ---
if [[ -n "$GHOSTTY_RESOURCES_DIR" ]]; then
  source "$GHOSTTY_RESOURCES_DIR"/shell-integration/zsh/ghostty-integration
fi

# --- Static, cached completions for wrapper names (no subprocess on startup) ---
# Generate once:
#   mkdir -p ~/.zsh/completions
#   kubectl completion zsh > ~/.zsh/completions/_kubectl
#   oc completion zsh       > ~/.zsh/completions/_oc
fpath=($HOME/.zsh/completions $fpath)

# --- Completion (cached, once) ---
# Use a per-host/version dump to avoid unnecessary rebuilds
ZSH_COMPDUMP="${XDG_CACHE_HOME:-$HOME/.cache}/zsh/.zcompdump-${HOST}-${ZSH_VERSION}"
mkdir -p "${ZSH_COMPDUMP:h}"
autoload -Uz compinit
# Use -C to skip expensive checks when the compdump exists
if [[ -f $ZSH_COMPDUMP ]]; then
  compinit -C -d "$ZSH_COMPDUMP"
else
  compinit -i -d "$ZSH_COMPDUMP"
fi
setopt complete_aliases

# --- History and shell options ---
HISTFILE="${XDG_STATE_HOME:-$HOME/.local/state}/zsh/history"
mkdir -p "${HISTFILE:h}"
HISTSIZE=200000
SAVEHIST=200000
setopt INC_APPEND_HISTORY        # write history incrementally
setopt SHARE_HISTORY             # share history across sessions
setopt HIST_IGNORE_ALL_DUPS      # remove older duplicate entries
setopt HIST_FIND_NO_DUPS         # skip duplicates when searching
setopt HIST_REDUCE_BLANKS        # trim superfluous blanks
setopt HIST_IGNORE_SPACE         # ignore commands starting with space
setopt HIST_VERIFY               # show command with history expansion before running
setopt HIST_FCNTL_LOCK           # use better locking for history file
setopt EXTENDED_HISTORY          # save timestamp and duration
setopt EXTENDED_GLOB             # better globbing
setopt INTERACTIVE_COMMENTS      # allow comments in interactive shell
setopt AUTO_PUSHD PUSHD_SILENT PUSHD_IGNORE_DUPS
setopt CORRECT                   # correct typos in commands
setopt COMPLETE_IN_WORD          # complete from both ends of a word
setopt ALWAYS_TO_END             # move cursor to end after completion
setopt AUTO_CD                   # cd by typing directory name if it's not a command
setopt AUTO_LIST                 # automatically list choices on ambiguous completion
setopt AUTO_MENU                 # show completion menu on successive tab presses
setopt NO_BEEP                   # disable beep on error
setopt NO_CASE_GLOB              # case-insensitive globbing
setopt NUMERIC_GLOB_SORT         # sort numeric filenames numerically

# Optional: byte-compile compdump for tiny extra speed
[[ ! -f ${ZSH_COMPDUMP}.zwc || $ZSH_COMPDUMP -nt ${ZSH_COMPDUMP}.zwc ]] && zcompile -R -- "${ZSH_COMPDUMP}.zwc" "$ZSH_COMPDUMP"

# --- Wrapper functions with fallback ---
kubectl() { if (( $+commands[kubecolor] )); then command kubecolor "$@"; else command kubectl "$@"; fi }
oc()      { if (( $+commands[kubecolor] )); then KUBECOLOR_KUBECTL=oc command kubecolor "$@"; else command oc "$@"; fi }

compdef _kubectl kubectl
compdef _oc oc

# --- PATH ---
# Deduplicate PATH entries
typeset -U path

# Add to PATH (prepend for priority)
path=("${KREW_ROOT:-$HOME/.krew}/bin" "$HOME/.local/bin" $path)

# Export PATH
export PATH

# --- Plugins (guarded). Keep ONLY ONE highlighter; fast is, well, faster. ---
# zsh-autosuggestions
[[ -r /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh ]] && \
  source /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh

# zsh-fast-syntax-highlighting (load AFTER completion & autosuggestions)
[[ -r /opt/homebrew/opt/zsh-fast-syntax-highlighting/share/zsh-fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh ]] && \
  source /opt/homebrew/opt/zsh-fast-syntax-highlighting/share/zsh-fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh

# If you prefer the regular highlighter, comment out the fast one above and use this instead (but not both):
# [[ -r /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]] && \
#   source /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

# zoxide (smart cd)
(( $+commands[zoxide] )) && eval "$(zoxide init zsh)"

# fzf (fuzzy finder): key bindings and completion
[[ -r /opt/homebrew/opt/fzf/shell/key-bindings.zsh ]] && source /opt/homebrew/opt/fzf/shell/key-bindings.zsh
[[ -r /opt/homebrew/opt/fzf/shell/completion.zsh    ]] && source /opt/homebrew/opt/fzf/shell/completion.zsh

# --- Completion styling ---
zstyle ':completion:*' menu select                              # enable selection menu
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'      # case-insensitive matching
[[ -n $LS_COLORS ]] && zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"  # use LS_COLORS for completion
zstyle ':completion:*' group-name ''                            # group results
zstyle ':completion:*' format '%B%d%b'                         # format group names
zstyle ':completion:*:descriptions' format '%U%F{cyan}%d%f%u'  # format descriptions
zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'
zstyle ':completion:*' rehash true                              # rehash on completion

# zsh-vi-mode (enhanced vi-mode; safe to load without bindkey -v)
# Disabled - not using vi-mode
# [[ -r /opt/homebrew/share/zsh-vi-mode/zsh-vi-mode.plugin.zsh ]] && \
#   source /opt/homebrew/share/zsh-vi-mode/zsh-vi-mode.plugin.zsh

# direnv (per-directory environment automation)
(( $+commands[direnv] )) && eval "$(direnv hook zsh)"

# Load history file after all plugins (some plugins may reset history settings)
fc -R "$HISTFILE" 2>/dev/null || true

# fzf-tab (enhanced completion UI) â€” load if installed
if [[ -r "${HOME}/.zsh/plugins/fzf-tab/fzf-tab.plugin.zsh" ]]; then
  source "${HOME}/.zsh/plugins/fzf-tab/fzf-tab.plugin.zsh"
fi

# --- Optional: vi-mode to leverage Starship's vimcmd_symbol ---
# bindkey -v
# KEYTIMEOUT=1

# Explicitly set emacs mode (default, but ensure vi-mode is not active)
bindkey -e

# --- Navigation keys (Home, End, Delete, Insert, PageUp, PageDown) ---
# These sequences match what Ghostty sends
bindkey '^[[H'    beginning-of-line          # Home
bindkey '^[[F'    end-of-line                # End
bindkey '^[[3~'   delete-char                # Delete
bindkey '^[[2~'   overwrite-mode             # Insert
bindkey '^[[5~'   history-search-backward    # Page Up - search history
bindkey '^[[6~'   history-search-forward     # Page Down - search history

# Alternative sequences (some terminals send these)
bindkey '^[[1~'   beginning-of-line          # Home (alternate)
bindkey '^[[4~'   end-of-line                # End (alternate)
bindkey '^[OH'    beginning-of-line          # Home (application mode)
bindkey '^[OF'    end-of-line                # End (application mode)

# With Ctrl modifier
bindkey '^[[1;5H' beginning-of-buffer-or-history  # Ctrl+Home
bindkey '^[[1;5F' end-of-buffer-or-history        # Ctrl+End
bindkey '^[[1;5C' forward-word               # Ctrl+Right
bindkey '^[[1;5D' backward-word              # Ctrl+Left

# With Shift modifier  
bindkey '^[[1;2C' forward-word               # Shift+Right
bindkey '^[[1;2D' backward-word              # Shift+Left

# --- Aliases ---
# Directory navigation
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias ~="cd ~"
alias -- -="cd -"
alias work="cd ~/workdir"

# Listing (eza if available, fallback to ls)
if (( $+commands[eza] )); then
  alias ls="eza"
  alias ll="eza -la --git"
  alias la="eza -la --git"
  alias l="eza -l"
  alias tree="eza --tree"
  alias lsi="eza --icons"  # with icons (when you want them)
else
  alias ll="ls -la"
  alias la="ls -la"
  alias l="ls -l"
  alias ls="ls -G"  # colorized ls on macOS
fi

# File operations
alias tailf="tail -f"

# Modern CLI replacements (with fallbacks)
if (( $+commands[bat] )); then
  alias cat="bat --paging=never"
  alias catp="bat"  # with pager
fi

if (( $+commands[rg] )); then
  alias grep="rg"
else
  alias grep="grep --color=auto"
fi
alias fgrep="fgrep --color=auto"
alias egrep="egrep --color=auto"

if (( $+commands[fd] )); then
  alias find="fd"
fi

if (( $+commands[btop] )); then
  alias top="btop"
elif (( $+commands[htop] )); then
  alias top="htop"
fi

if (( $+commands[duf] )); then
  alias df="duf"
fi

if (( $+commands[dust] )); then
  alias du="dust"
fi

if (( $+commands[delta] )); then
  # Git will use delta automatically if configured
  alias diff="delta"
fi

if (( $+commands[lazygit] )); then
  alias lg="lazygit"
fi

if (( $+commands[lazydocker] )); then
  alias ld="lazydocker"
fi

# Kubernetes tools
if (( $+commands[k9s] )); then
  alias kk="k9s"  # quick k9s
fi

if (( $+commands[kubectx] )); then
  alias kctx="kubectx"
  alias kns="kubens"
fi

if (( $+commands[stern] )); then
  alias klog="stern"  # multi-pod logs
fi

# Editors
alias vi="vim"
alias vim="vim"
alias edit="vim"

# Kubernetes
alias k=kubectl
alias kgp="kubectl get pods"
alias kgs="kubectl get svc"
alias kgd="kubectl get deploy"
alias kgn="kubectl get nodes"
alias kdp="kubectl describe pod"
alias kdel="kubectl delete"
alias kaf="kubectl apply -f"
alias kdf="kubectl delete -f"
# Add your own cluster aliases here, e.g.:
# alias dev-cluster="kubie ctx my-dev-cluster"
# alias prod-cluster="kubie ctx my-prod-cluster"

# Git shortcuts
alias gs="git status"
alias ga="git add"
alias gc="git commit"
alias gp="git push"
alias gl="git pull"
alias gd="git diff"
alias gb="git branch"
alias gco="git checkout"
alias glog="git log --oneline --graph --decorate"

# System
alias df="df -h"
alias du="du -h"
alias free="top -l 1 | head -n 10 | grep PhysMem"  # macOS memory info
alias ports="lsof -i -P -n | grep LISTEN"          # show listening ports

# Safety
alias rm="rm -i"
alias cp="cp -i"
alias mv="mv -i"
alias kpk="k8pk"

# Misc
alias reload="source ~/.zshrc"
alias path="echo $PATH | tr ':' '\n'"
alias now="date '+%Y-%m-%d %H:%M:%S'"

# Cheat sheets
alias tmux-help="cat ~/.config/tmux-cheatsheet.txt"
alias th="tmux-help"
alias vim-help="cat ~/.config/vim-cheatsheet.txt"
alias vh="vim-help"

# Smart tmux session management
# Creates/attaches to session named after current folder + k8s context
function ts() {
  local session_name="${1:-}"
  
  if [[ -z "$session_name" ]]; then
    # Auto-generate name from folder and k8s context
    local folder="${PWD:t}"
    [[ -z "$folder" || "$folder" == "/" ]] && folder="root"
    
    local k8s_ctx=""
    if (( $+commands[kubectl] )); then
      k8s_ctx=$(kubectl config current-context 2>/dev/null)
      k8s_ctx=$(_shorten_k8s_context "$k8s_ctx")
    fi
    
    if [[ -n "$k8s_ctx" ]]; then
      session_name="${folder}_${k8s_ctx}"
    else
      session_name="$folder"
    fi
  fi
  
  # Sanitize name (tmux doesn't like dots and colons)
  session_name="${session_name//[.:]/-}"
  
  if tmux has-session -t "$session_name" 2>/dev/null; then
    tmux attach -t "$session_name"
  else
    tmux new-session -s "$session_name"
  fi
}

# List and pick session with fzf (if available)
function tsp() {
  if (( $+commands[fzf] )); then
    local session=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | fzf --height 40% --reverse)
    [[ -n "$session" ]] && tmux attach -t "$session"
  else
    tmux list-sessions
    echo "Install fzf for interactive picker, or use: tmux attach -t SESSION"
  fi
}

alias tls="tmux list-sessions"
alias tks="tmux kill-session -t"
alias tka="tmux kill-server"  # kill all

# --- Useful functions ---
# Create directory and cd into it
mkcd() { mkdir -p "$1" && cd "$1" }

# Extract various archive formats
extract() {
  if [ -f "$1" ]; then
    case "$1" in
      *.tar.bz2)   tar xjf "$1"     ;;
      *.tar.gz)    tar xzf "$1"     ;;
      *.bz2)       bunzip2 "$1"     ;;
      *.rar)       unrar e "$1"     ;;
      *.gz)        gunzip "$1"      ;;
      *.tar)       tar xf "$1"      ;;
      *.tbz2)      tar xjf "$1"     ;;
      *.tgz)       tar xzf "$1"     ;;
      *.zip)       unzip "$1"       ;;
      *.Z)         uncompress "$1"  ;;
      *.7z)        7z x "$1"        ;;
      *)           echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Find files by name (case-insensitive)
ff() { find . -type f -iname "*$1*" }

# Find directories by name (case-insensitive)
fdir() { find . -type d -iname "*$1*" }

# Quick search in history
h() { history | grep "$1" }

# Show top 10 commands from history
topcmd() { history | awk '{print $2}' | sort | uniq -c | sort -rn | head -10 }

# --- Environment variables ---
export EDITOR="vim"
export VISUAL="vim"
export PAGER="less"
export LESS="-R"

# --- Extra tools ---
[[ -r ~/.config/k8pk.sh ]] && source ~/.config/k8pk.sh

# --- Prompt: Starship or Powerlevel10k (Starship-style) ---
# Choice is set by install.sh and stored in ~/.config/terminal-fix-prompt
if [[ -f ~/.config/terminal-fix-prompt ]]; then
  source ~/.config/terminal-fix-prompt 2>/dev/null
fi
if [[ "$PROMPT_ENGINE" == "p10k" ]]; then
  if [[ -r "${HOME}/.zsh/themes/powerlevel10k/powerlevel10k.zsh-theme" ]]; then
    source "${HOME}/.zsh/themes/powerlevel10k/powerlevel10k.zsh-theme"
    [[ -f ~/.p10k.zsh ]] && source ~/.p10k.zsh
  else
    # Fallback to Starship if p10k not installed
    (( $+commands[starship] )) && eval "$(starship init zsh)"
  fi
else
  (( $+commands[starship] )) && eval "$(starship init zsh)"
fi

# Re-apply history options after prompt init (p10k lean config uses emulate -L zsh
# inside its anonymous function which temporarily resets all options; this is a safeguard)
setopt INC_APPEND_HISTORY SHARE_HISTORY HIST_IGNORE_ALL_DUPS HIST_FIND_NO_DUPS \
       HIST_REDUCE_BLANKS HIST_IGNORE_SPACE HIST_VERIFY HIST_FCNTL_LOCK EXTENDED_HISTORY

# --- Automatic Tab/Window Title ---
# Cache k8s context to avoid calling kubectl on every prompt
_CACHED_K8S_CTX=""
_CACHED_K8S_TIME=0

function _shorten_k8s_context() {
  local ctx="$1"
  
  # OpenShift/OCP context: namespace/api-CLUSTER-domain-com:port/user
  # Extract cluster name between api- and the domain suffix
  # Customize these patterns to match your OpenShift API URL format:
  # if [[ "$ctx" =~ /api-([a-zA-Z0-9_-]+)-yourdomain ]]; then
  #   echo "${match[1]}"
  #   return
  # fi
  
  # OpenShift API URLs with dots: api.CLUSTER.domain.com:port -> CLUSTER
  if [[ "$ctx" =~ ^api\.([^.]+)\. ]]; then
    echo "${match[1]}"
    return
  fi
  
  # AWS EKS: arn:aws:eks:region:account:cluster/NAME -> NAME
  if [[ "$ctx" =~ :cluster/([^/]+)$ ]]; then
    echo "${match[1]}"
    return
  fi
  
  # GKE: gke_project_region_NAME -> NAME
  if [[ "$ctx" =~ ^gke_.*_([^_]+)$ ]]; then
    echo "${match[1]}"
    return
  fi
  
  # Kubeadm: kubernetes-admin@CLUSTER -> CLUSTER
  if [[ "$ctx" =~ ^kubernetes-admin@(.+)$ ]]; then
    echo "${match[1]}"
    return
  fi
  
  # Docker desktop
  [[ "$ctx" == "docker-desktop" ]] && echo "docker" && return
  
  # Custom cluster name patterns -- add your own here, e.g.:
  # if [[ "$ctx" =~ (my-prefix-[a-zA-Z0-9-]+) ]]; then
  #   echo "${match[1]}"
  #   return
  # fi
  
  # Generic: extract just the first segment after any /api- pattern
  if [[ "$ctx" =~ /api-([^:/]+) ]]; then
    local extracted="${match[1]}"
    # Remove trailing domain-like parts
    extracted="${extracted%-com}"
    extracted="${extracted%-io}"
    extracted="${extracted%-org}"
    echo "$extracted"
    return
  fi
  
  # Default: return as-is but truncate if too long
  if (( ${#ctx} > 25 )); then
    echo "${ctx:0:22}..."
  else
    echo "$ctx"
  fi
}

function _get_k8s_context() {
  local now=$(date +%s)
  # Refresh cache every 5 seconds
  if (( now - _CACHED_K8S_TIME > 5 )); then
    if (( $+commands[kubectl] )); then
      local raw_ctx=$(kubectl config current-context 2>/dev/null)
      _CACHED_K8S_CTX=$(_shorten_k8s_context "$raw_ctx")
    fi
    _CACHED_K8S_TIME=$now
  fi
  echo "$_CACHED_K8S_CTX"
}

function _set_terminal_title() {
  local title_dir="${PWD/#$HOME/~}"
  title_dir="${title_dir:t}"  # basename only
  [[ -z "$title_dir" ]] && title_dir="~"
  
  local k8s_ctx=$(_get_k8s_context)
  local title="$title_dir"
  [[ -n "$k8s_ctx" ]] && title="$title | $k8s_ctx"
  
  # Set terminal/pane title
  if [[ -n "$TMUX" ]]; then
    # Inside tmux: set pane title (tmux passes through to outer terminal)
    print -Pn "\e]2;${title}\a"           # Set tmux pane title
    tmux rename-window "$title_dir" 2>/dev/null  # Set tmux window name to just folder
    # Also pass through to outer terminal (Ghostty)
    print -Pn "\ePtmux;\e\e]0;${title}\a\e\\"
  else
    # Outside tmux: set terminal title directly
    print -Pn "\e]0;${title}\a"
  fi
}

# Use zle-line-init to set title RIGHT before prompt is ready for input
# This ensures it runs AFTER everything else
function zle-line-init() {
  _set_terminal_title
}
zle -N zle-line-init

# Show running command in title while executing
function _set_title_preexec() {
  local cmd="${1[(w)1]}"
  if [[ -n "$TMUX" ]]; then
    print -Pn "\e]2;${cmd} ...\a"
    print -Pn "\ePtmux;\e\e]0;${cmd} ...\a\e\\"
  else
    print -Pn "\e]0;${cmd} ...\a"
  fi
}
autoload -Uz add-zsh-hook
add-zsh-hook preexec _set_title_preexec

# --- History: Save on exit ---
# Ensure history is saved when shell exits
zshaddhistory() {
  # This function is called before each command is added to history
  # Return 0 to add, 1 to skip
  return 0
}

# Ghostty integration is now loaded early in the file (see top)

# Save history on exit
zshexit() {
  fc -W "$HISTFILE" 2>/dev/null || true
}

# --- iTerm2 integration (fallback for non-Ghostty use) ---
if [[ -z "$GHOSTTY_RESOURCES_DIR" ]]; then
  test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"
fi

# --- Auto-start tmux (only in real terminals, not IDE or nested) ---
# Uncomment to enable:
# if [[ -z "$TMUX" ]] && [[ -z "$VSCODE_INJECTION" ]] && [[ -z "$CURSOR_TRACE_ID" ]] && [[ -n "$PS1" ]] && [[ -o interactive ]]; then
#   # Option 1: Attach to 'main' session or create it
#   tmux attach -t main 2>/dev/null || tmux new -s main
#   
#   # Option 2: Use smart session (folder + k8s context)
#   # ts
# fi
